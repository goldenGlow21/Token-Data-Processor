{"SourceCode": "/**\r\n\r\n88 Dollar Millionaire - $88\r\n$88 token will add exactly 88$ worth of ethereum against all of the supply. We will start off with 88$ worth of liquidity.\r\n\r\nBut to boost it as we grow we will add 7% liqudity tax for buying and selling which will in return grow our initial liquidity.\r\n\r\n \r\n\r\n$88 tokens only utility is to reach 88K marketcap starting out with just 88$ worth of liquidity.\r\n\r\n*/\r\n\r\n// AUTO LP \r\n// 7/7 TAX --> LP\r\n// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.0;\r\nabstract contract Context {\r\nfunction _msgSender() internal view virtual returns (address) {\r\n    return msg.sender;\r\n}\r\nfunction _msgData() internal view virtual returns (bytes calldata) {\r\n    return msg.data;\r\n}\r\n}\r\ninterface IERC20 {\r\n function totalSupply() external view returns (uint256);\r\nfunction balanceOf(address account) external view returns (uint256);\r\nfunction transfer(address recipient, uint256 amount) external returns (bool);\r\nfunction allowance(address owner, address spender) external view returns (uint256);\r\nfunction approve(address spender, uint256 amount) external returns (bool);\r\nfunction transferFrom(address sender,address recipient,uint256 amount) external returns (bool);\r\nevent Transfer(address indexed from, address indexed to, uint256 value);\r\nevent Approval(address indexed owner, address indexed spender, uint256 value);\r\n}\r\nlibrary Address {\r\nfunction isContract(address account) internal view returns (bool) {\r\n    // According to EIP-1052, 0x0 is the value returned for not-yet created accounts\r\n    // and 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 is returned\r\n    // for accounts without code, i.e. `keccak256('')`\r\n    bytes32 codehash;\r\n    bytes32 accountHash = 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470;\r\n    // solhint-disable-next-line no-inline-assembly\r\n    assembly { codehash := extcodehash(account) }\r\n    return (codehash != accountHash && codehash != 0x0);\r\n}\r\nfunction sendValue(address payable recipient, uint256 amount) internal {\r\n    require(address(this).balance >= amount, \"Address: insufficient balance\");\r\n    // solhint-disable-next-line avoid-low-level-calls, avoid-call-value\r\n    (bool success, ) = recipient.call{ value: amount }(\"\");\r\n    require(success, \"Address: unable to send value, recipient may have reverted\");\r\n}\r\nfunction functionCall(address target, bytes memory data) internal returns (bytes memory) {\r\n  return functionCall(target, data, \"Address: low-level call failed\");\r\n}\r\nfunction functionCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {\r\n    return _functionCallWithValue(target, data, 0, errorMessage);\r\n}\r\nfunction functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\r\n    return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\r\n}\r\nfunction functionCallWithValue(address target, bytes memory data, uint256 value, string memory errorMessage) internal returns (bytes memory) {\r\n    require(address(this).balance >= value, \"Address: insufficient balance for call\");\r\n    return _functionCallWithValue(target, data, value, errorMessage);\r\n}\r\nfunction _functionCallWithValue(address target, bytes memory data, uint256 weiValue, string memory errorMessage) private returns (bytes memory) {\r\n    require(isContract(target), \"Address: call to non-contract\");\r\n    (bool success, bytes memory returndata) = target.call{ value: weiValue }(data);\r\n    if (success) {\r\n        return returndata;\r\n    } else {\r\n    \r\n        if (returndata.length > 0) {\r\n            assembly {\r\n                let returndata_size := mload(returndata)\r\n                revert(add(32, returndata), returndata_size)\r\n            }\r\n        } else {\r\n            revert(errorMessage);\r\n        }\r\n    }\r\n}\r\n}\r\nabstract contract Ownable is Context {\r\naddress private _owner;\r\nevent OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n/**\r\n * @dev Initializes the contract setting the deployer as the initial owner.\r\n */\r\nconstructor() {\r\n    _setOwner(_msgSender());\r\n}\r\n/**\r\n * @dev Returns the address of the current owner.\r\n */\r\nfunction owner() public view virtual returns (address) {\r\n    return _owner;\r\n}\r\n/**\r\n * @dev Throws if called by any account other than the owner.\r\n */\r\nmodifier onlyOwner() {\r\n    require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\r\n    _;\r\n}\r\n/**\r\n * @dev Leaves the contract without owner. It will not be possible to call\r\n * `onlyOwner` functions anymore. Can only be called by the current owner.\r\n *\r\n * NOTE: Renouncing ownership will leave the contract without an owner,\r\n * thereby removing any functionality that is only available to the owner.\r\n */\r\nfunction renounceOwnership() public virtual onlyOwner {\r\n    _setOwner(address(0));\r\n}\r\n/**\r\n * @dev Transfers ownership of the contract to a new account (`newOwner`).\r\n * Can only be called by the current owner.\r\n */\r\nfunction transferOwnership(address newOwner) public virtual onlyOwner {\r\n    require(newOwner != address(0), \"Ownable: new owner is the zero address\");\r\n    _setOwner(newOwner);\r\n}\r\nfunction _setOwner(address newOwner) private {\r\n    address oldOwner = _owner;\r\n    _owner = newOwner;\r\n    emit OwnershipTransferred(oldOwner, newOwner);\r\n}\r\n}\r\ncontract MILLIONAIRE is Context,IERC20, Ownable{\r\nusing Address for address;\r\nstring private _name = \"88 Dollar Millionaire\";\r\nstring private _symbol = \"$88\";\r\nuint8 private _decimals = 18;\r\nuint256 totalFeeFortx = 0;\r\n  uint256 maxWalletTreshold = 1;\r\nuint256 maxTxTreshold = 2;\r\nuint256 private swapTreshold =1;\r\nuint256 private currentThreshold = 10; //Once the token value goes up this number can be decreased (To reduce price impact on asset)\r\nuint256 private _totalSupply = (10000000 * 10**4) * 10**_decimals; //\r\nuint256 public requiredTokensToSwap = _totalSupply * swapTreshold /1000;\r\nmapping (address => uint256) private _balances;\r\nmapping (address => bool) private _excludedFromFees;\r\nmapping (address => mapping (address => uint256)) private _allowances;\r\nmapping (address => bool) public automatedMarketMakerPairs;\r\naddress _owner;\r\naddress payable public marketingAddress = payable(0x68c6AbEcC5842aB6c4514856eE0FDcd7646d07ec);\r\nuint256 maxWalletAmount = _totalSupply*maxWalletTreshold/200; // starting 2%\r\nuint256 maxTxAmount = _totalSupply*maxTxTreshold/100;\r\nmapping (address => bool) botWallets;\r\nbool botTradeEnabled = false;\r\nbool checkWalletSize = true;\r\nmapping (address => bool) private _liquidityHolders;\r\nmapping (address => bool) private presaleAddresses;\r\n//7% Buy Tax + 7% Sell Tax \r\nuint256 private buyliqFee = 6; //6\r\nuint256 private buyprevLiqFee = 0;\r\nuint256 private buymktFee = 1;//1\r\nuint256 private buyPrevmktFee = 0;\r\nbool private tradeEnabled = false;\r\n uint256 private sellliqFee = 6;\r\nuint256 private sellprevLiqFee = 0;\r\nuint256 private sellmktFee = 1;\r\nuint256 private sellPrevmktFee = 0;\r\n bool public inSwapAndLiquify;\r\nbool public swapAndLiquifyEnabled = true;\r\naddress public immutable deadAddress = 0x000000000000000000000000000000000000dEaD;\r\nuint256 private mktTokens = 0;\r\nuint256 private liqTokens = 0;\r\n event SwapAndLiquify(uint256 tokensSwapped,\r\n    uint256 ethReceived,\r\n    uint256 tokensIntoLiquidity\r\n);\r\nevent tokensSwappedDuringTokenomics(uint256 amount);\r\nevent SetAutomatedMarketMakerPair(address indexed pair, bool indexed value);\r\n // 0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D\r\nIUniswapV2Router02 _router;\r\naddress public uniswapV2Pair;\r\n//Balances tracker\r\nmodifier lockTheSwap{\r\n    inSwapAndLiquify = true;\r\n    _;\r\n    inSwapAndLiquify = false;\r\n}\r\n constructor(){\r\n    _balances[_msgSender()] = _totalSupply;\r\n    //0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D mainnet and all networks\r\n    IUniswapV2Router02 _uniRouter = IUniswapV2Router02(0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D);\r\n     uniswapV2Pair = IUniswapV2Factory(_uniRouter.factory())\r\n        .createPair(address(this), _uniRouter.WETH());\r\n     _excludedFromFees[owner()] = true;     \r\n    _excludedFromFees[address(this)] = true;// exclude owner and contract instance from fees\r\n    _router = _uniRouter;\r\n    _liquidityHolders[address(_router)] = true;\r\n    _liquidityHolders[owner()] = true;\r\n    _liquidityHolders[address(this)] = true;\r\n    _setAutomatedMarketMakerPair(address(uniswapV2Pair), true);\r\n    emit Transfer(address(0),_msgSender(),_totalSupply);\r\n}\r\nreceive() external payable{}\r\n//general token data and tracking of balances to be swapped.\r\nfunction getOwner()external view returns(address){\r\n        return owner();\r\n}\r\nfunction currentmktTokens() external view returns (uint256){\r\n        return mktTokens;\r\n }\r\n function currentLiqTokens() external view returns (uint256){\r\n        return liqTokens;\r\n }\r\n function totalSupply() external view override returns (uint256){\r\n        return _totalSupply;\r\n }\r\nfunction balanceOf(address account) public view override returns (uint256){\r\n    return _balances[account];\r\n}\r\nfunction transfer(address recipient, uint256 amount) external override returns (bool){\r\n        _transfer(_msgSender(),recipient,amount);\r\n        return true;\r\n}\r\nfunction allowance(address owner, address spender) external view override returns (uint256){\r\n        return _allowances[owner][spender];\r\n}\r\nfunction approve(address spender, uint256 amount) external override returns (bool){\r\n        _approve(_msgSender(),spender,amount);\r\n        return true;\r\n}\r\nfunction decimals()external view returns(uint256){\r\n    return _decimals;\r\n}\r\nfunction name() external view returns (string memory) {\r\n    return _name;\r\n}\r\nfunction symbol() external view returns (string memory){\r\n    return _symbol;\r\n}\r\n    function updateMaxTxTreshold(uint256 newVal) public onlyOwner{\r\n    maxTxTreshold = newVal;\r\n    maxTxAmount = _totalSupply*maxTxTreshold/100;// 1%\r\n}\r\n function updateMaxWalletTreshold(uint256 newVal) public onlyOwner{\r\n    maxWalletTreshold = newVal;\r\n    maxWalletAmount = _totalSupply*maxWalletTreshold/100;\r\n}\r\n function transferFrom(\r\n    address sender,\r\n    address recipient,\r\n    uint256 amount\r\n) public override returns (bool){\r\n    require(amount <= _allowances[sender][_msgSender()], \"ERC20: transfer amount exceeds allowance\");\r\n    _transfer(sender, recipient, amount);\r\n    _approve(sender, _msgSender(), _allowances[sender][_msgSender()] - amount);\r\n    return true;\r\n}\r\n//Tokenomics related functions\r\nfunction addBotWallet (address payable detectedBot, bool isBot) public onlyOwner{\r\n    botWallets[detectedBot] = isBot;\r\n}\r\nfunction currentbuyliqFee() public view returns (uint256){\r\n        return buyliqFee;\r\n}\r\nfunction currentbuymktfee() public view returns (uint256){\r\n        return buymktFee;\r\n}\r\n  function currentsellLiqFee() public view returns (uint256){\r\n        return sellliqFee;\r\n}\r\nfunction currentsellmktfee() public view returns (uint256){\r\n        return sellmktFee;\r\n}\r\nfunction currentThresholdInt()public view returns (uint256){\r\n    return currentThreshold;\r\n}\r\nfunction isExcluded(address toCheck)public view returns (bool){\r\n        return _excludedFromFees[toCheck];\r\n}\r\nfunction _transfer(address from, address to, uint256 amount) internal{\r\n     require(from != address(0), \"ERC20: transfer from the zero address\");\r\n    require(to != address(0), \"ERC20: transfer to the zero address\");\r\n    require(amount > 0,\"ERC20: transfered amount must be greater than zero\");\r\n    uint256 senderBalance = _balances[from];\r\n    require(senderBalance >= amount, \"ERC20: transfer amount exceeds balance\");\r\n    if(tradeEnabled == false){\r\n        require(_liquidityHolders[to] || _liquidityHolders[from],\"Cant trade, trade is disabled\");\r\n    }\r\n    if(_liquidityHolders[to]==false && _liquidityHolders[from]==false){\r\n    require(amount <= maxTxAmount, \"Transfer amount exceeds the maxTxAmount.\");\r\n     if(from == uniswapV2Pair){\r\n            require(balanceOf(to)+amount <= maxWalletAmount);\r\n        }\r\n    }\r\n    uint256 inContractBalance = balanceOf(address(this));\r\n    if(inContractBalance >=requiredTokensToSwap &&\r\n        !inSwapAndLiquify &&\r\n        from != uniswapV2Pair &&\r\n        swapAndLiquifyEnabled){\r\n            if(inContractBalance >= requiredTokensToSwap ){\r\n                inContractBalance = requiredTokensToSwap;\r\n                swapForTokenomics(inContractBalance);\r\n            }\r\n        }\r\n        bool takeFees = true;\r\n    \r\n    \r\n        if(_excludedFromFees[from] || _excludedFromFees[to]) {\r\n            totalFeeFortx = 0;\r\n            takeFees = false;\r\n       \r\n        }\r\n        uint256 mktAmount = 0;\r\n        uint256 liqAmount = 0;  // Amount to be added to liquidity.\r\n        if(takeFees){\r\n        \r\n        \r\n            //bot fees\r\n            if(botWallets[from] == true||botWallets[to]==true){\r\n                revert(\"No bots can trade\");\r\n            }\r\n            //Selling fees\r\n            if (automatedMarketMakerPairs[to] && to != address(_router) ){\r\n                    totalFeeFortx = 0;\r\n                    mktAmount = amount * sellmktFee/100;\r\n                    liqAmount = amount * sellliqFee/100;\r\n                    totalFeeFortx = mktAmount + liqAmount;\r\n            }\r\n            //Buy Fees\r\n            else if(automatedMarketMakerPairs[from] && from != address(_router)) {\r\n        \r\n                totalFeeFortx = 0;\r\n                mktAmount = amount * buymktFee/100;\r\n                liqAmount = amount * buyliqFee/100;\r\n                totalFeeFortx = mktAmount + liqAmount ;\r\n            }\r\n        \r\n        }\r\n        _balances[from] = senderBalance - amount;\r\n        _balances[to] += amount - mktAmount - liqAmount;\r\n      if(liqAmount != 0) {\r\n        _balances[address(this)] += totalFeeFortx;\r\n        //tLiqTotal += liqAmount;\r\n        liqTokens += liqAmount;\r\n        mktTokens += mktAmount;\r\n        emit Transfer(from, address(this), totalFeeFortx);\r\n    \r\n        }\r\n        emit Transfer(from, to,amount-totalFeeFortx);\r\n    \r\n }\r\nfunction swapForTokenomics(uint256 balanceToswap) private lockTheSwap{\r\n    swapAndLiquify(liqTokens);\r\n    swapTokensForETHmkt(mktTokens);\r\n    emit tokensSwappedDuringTokenomics(balanceToswap);\r\n    mktTokens = 0;\r\n    liqTokens = 0;\r\n}\r\nfunction swapTokensForETHmkt(uint256 amount)private {\r\n    address[] memory path = new address[](2);\r\n    path[0] = address(this);\r\n    path[1] = _router.WETH();\r\n    _approve(address(this), address(_router), amount);\r\n     _router.swapExactTokensForETHSupportingFeeOnTransferTokens(\r\n        amount,\r\n        0, // Accept any amount of ETH.\r\n        path,\r\n        marketingAddress,\r\n        block.timestamp\r\n    );\r\n}\r\nfunction tradeStatus(bool status) public onlyOwner{\r\n    tradeEnabled = status;\r\n}\r\nfunction swapAndLiquify(uint256 liqTokensPassed) private {\r\n    uint256 half = liqTokensPassed / 2;\r\n    uint256 otherHalf = liqTokensPassed - half;\r\n    uint256 initialBalance = address(this).balance;\r\n    swapTokensForETH(half);\r\n    uint256 newBalance = address(this).balance - (initialBalance);\r\n    addLiquidity(otherHalf, newBalance);\r\n    emit SwapAndLiquify(half,newBalance,otherHalf);\r\n}\r\nfunction swapTokensForETH(uint256 tokenAmount) private{\r\n    address[] memory path = new address[](2);\r\n    path[0] = address(this);\r\n    path[1] = _router.WETH();\r\n    _approve(address(this), address(_router), tokenAmount);\r\n     _router.swapExactTokensForETHSupportingFeeOnTransferTokens(\r\n        tokenAmount,\r\n        0, // Accept any amount of ETH.\r\n        path,\r\n        address(this),\r\n        block.timestamp\r\n    );\r\n}\r\n function addLiquidity(uint256 tokenAmount,uint256 ethAmount) private{\r\n    _approve(address(this), address(_router), tokenAmount);\r\n    _router.addLiquidityETH{value:ethAmount}(\r\n        address(this),\r\n        tokenAmount,\r\n        0,\r\n        0,\r\n        deadAddress,// tr\r\n        block.timestamp\r\n    );\r\n}\r\nfunction _approve(address owner,address spender, uint256 amount) internal{\r\n    require(owner != address(0), \"ERC20: approve from the zero address\");\r\n    require(spender != address(0), \"ERC20: approve to the zero address\");\r\n    _allowances[owner][spender] = amount;\r\n    emit Approval(owner, spender, amount);\r\n}\r\n//Fees related functions\r\nfunction addToExcluded(address toExclude) public onlyOwner{\r\n    _excludedFromFees[toExclude] = true;\r\n}\r\nfunction removeFromExcluded(address toRemove) public onlyOwner{\r\n    _excludedFromFees[toRemove] = false;\r\n}\r\nfunction updateThreshold(uint newThreshold) public onlyOwner{\r\n    currentThreshold = newThreshold;\r\n}\r\n//Marketing related\r\nfunction setMktAddress(address newAddress) external onlyOwner{\r\n    marketingAddress = payable(newAddress);\r\n}\r\nfunction transferAssetsETH(address payable to, uint256 amount) internal{\r\n        to.transfer(amount);\r\n}\r\nfunction _setAutomatedMarketMakerPair(address pair, bool value) private {\r\n    automatedMarketMakerPairs[pair] = value;\r\n    emit SetAutomatedMarketMakerPair(pair, value);\r\n}\r\nfunction buyFee(uint256 newAmount) public onlyOwner{\r\n         buymktFee= newAmount;\r\n}\r\nfunction sellFee(uint256 newAmount)public onlyOwner{\r\n         sellmktFee= newAmount;\r\n}\r\nfunction currentMaxWallet() public view returns(uint256){\r\n    return maxWalletAmount;\r\n}\r\nfunction currentMaxTx() public view returns(uint256){\r\n    return maxTxAmount;\r\n}\r\nfunction updateSwapTreshold(uint256 newVal) public onlyOwner{\r\n    swapTreshold = newVal;\r\n    requiredTokensToSwap = _totalSupply*swapTreshold/1000;\r\n }\r\nfunction currentTrade() public view returns (bool){\r\n    return tradeEnabled;\r\n}\r\nfunction currentSwap() public view returns(uint256){\r\n    return swapTreshold;\r\n}\r\nfunction currentTokensToSwap() public view returns(uint256){\r\n    return requiredTokensToSwap;\r\n}\r\n}\r\ninterface IUniswapV2Factory {\r\nevent PairCreated(address indexed token0, address indexed token1, address pair, uint);\r\nfunction feeTo() external view returns (address);\r\nfunction feeToSetter() external view returns (address);\r\nfunction getPair(address tokenA, address tokenB) external view returns (address pair);\r\nfunction allPairs(uint) external view returns (address pair);\r\nfunction allPairsLength() external view returns (uint);\r\nfunction createPair(address tokenA, address tokenB) external returns (address pair);\r\nfunction setFeeTo(address) external;\r\nfunction setFeeToSetter(address) external;\r\n}\r\ninterface IUniswapV2Pair {\r\nevent Approval(address indexed owner, address indexed spender, uint value);\r\nevent Transfer(address indexed from, address indexed to, uint value);\r\nfunction name() external pure returns (string memory);\r\nfunction symbol() external pure returns (string memory);\r\nfunction decimals() external pure returns (uint8);\r\nfunction totalSupply() external view returns (uint);\r\nfunction balanceOf(address owner) external view returns (uint);\r\nfunction allowance(address owner, address spender) external view returns (uint);\r\nfunction approve(address spender, uint value) external returns (bool);\r\nfunction transfer(address to, uint value) external returns (bool);\r\nfunction transferFrom(address from, address to, uint value) external returns (bool);\r\nfunction DOMAIN_SEPARATOR() external view returns (bytes32);\r\nfunction PERMIT_TYPEHASH() external pure returns (bytes32);\r\nfunction nonces(address owner) external view returns (uint);\r\nfunction permit(address owner, address spender, uint value, uint deadline, uint8 v, bytes32 r, bytes32 s) external;\r\nevent Mint(address indexed sender, uint amount0, uint amount1);\r\nevent Burn(address indexed sender, uint amount0, uint amount1, address indexed to);\r\nevent Swap(\r\n    address indexed sender,\r\n    uint amount0In,\r\n    uint amount1In,\r\n    uint amount0Out,\r\n    uint amount1Out,\r\n    address indexed to\r\n);\r\nevent Sync(uint112 reserve0, uint112 reserve1);\r\nfunction MINIMUM_LIQUIDITY() external pure returns (uint);\r\nfunction factory() external view returns (address);\r\nfunction token0() external view returns (address);\r\nfunction token1() external view returns (address);\r\nfunction getReserves() external view returns (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast);\r\nfunction price0CumulativeLast() external view returns (uint);\r\nfunction price1CumulativeLast() external view returns (uint);\r\nfunction kLast() external view returns (uint);\r\nfunction mint(address to) external returns (uint liquidity);\r\nfunction burn(address to) external returns (uint amount0, uint amount1);\r\nfunction swap(uint amount0Out, uint amount1Out, address to, bytes calldata data) external;\r\nfunction skim(address to) external;\r\nfunction sync() external;\r\nfunction initialize(address, address) external;\r\n}\r\ninterface IUniswapV2Router01 {\r\nfunction factory() external pure returns (address);\r\nfunction WETH() external pure returns (address);\r\nfunction addLiquidity(\r\n    address tokenA,\r\n    address tokenB,\r\n    uint amountADesired,\r\n    uint amountBDesired,\r\n    uint amountAMin,\r\n    uint amountBMin,\r\n    address to,\r\n    uint deadline\r\n) external returns (uint amountA, uint amountB, uint liquidity);\r\nfunction addLiquidityETH(\r\n    address token,\r\n    uint amountTokenDesired,\r\n    uint amountTokenMin,\r\n    uint amountETHMin,\r\n    address to,\r\n    uint deadline\r\n) external payable returns (uint amountToken, uint amountETH, uint liquidity);\r\nfunction removeLiquidity(\r\n    address tokenA,\r\n    address tokenB,\r\n    uint liquidity,\r\n    uint amountAMin,\r\n    uint amountBMin,\r\n    address to,\r\n    uint deadline\r\n) external returns (uint amountA, uint amountB);\r\nfunction removeLiquidityETH(\r\n    address token,\r\n    uint liquidity,\r\n    uint amountTokenMin,\r\n    uint amountETHMin,\r\n    address to,\r\n    uint deadline\r\n) external returns (uint amountToken, uint amountETH);\r\nfunction removeLiquidityWithPermit(\r\n    address tokenA,\r\n    address tokenB,\r\n    uint liquidity,\r\n    uint amountAMin,\r\n    uint amountBMin,\r\n    address to,\r\n    uint deadline,\r\n    bool approveMax, uint8 v, bytes32 r, bytes32 s\r\n) external returns (uint amountA, uint amountB);\r\nfunction removeLiquidityETHWithPermit(\r\n    address token,\r\n    uint liquidity,\r\n    uint amountTokenMin,\r\n    uint amountETHMin,\r\n    address to,\r\n    uint deadline,\r\n    bool approveMax, uint8 v, bytes32 r, bytes32 s\r\n) external returns (uint amountToken, uint amountETH);\r\nfunction swapExactTokensForTokens(\r\n    uint amountIn,\r\n    uint amountOutMin,\r\n    address[] calldata path,\r\n    address to,\r\n    uint deadline\r\n) external returns (uint[] memory amounts);\r\nfunction swapTokensForExactTokens(\r\n    uint amountOut,\r\n    uint amountInMax,\r\n    address[] calldata path,\r\n    address to,\r\n    uint deadline\r\n) external returns (uint[] memory amounts);\r\nfunction swapExactETHForTokens(uint amountOutMin, address[] calldata path, address to, uint deadline)\r\n    external\r\n    payable\r\n    returns (uint[] memory amounts);\r\nfunction swapTokensForExactETH(uint amountOut, uint amountInMax, address[] calldata path, address to, uint deadline)\r\n    external\r\n    returns (uint[] memory amounts);\r\nfunction swapExactTokensForETH(uint amountIn, uint amountOutMin, address[] calldata path, address to, uint deadline)\r\n    external\r\n    returns (uint[] memory amounts);\r\nfunction swapETHForExactTokens(uint amountOut, address[] calldata path, address to, uint deadline)\r\n    external\r\n    payable\r\n    returns (uint[] memory amounts);\r\nfunction quote(uint amountA, uint reserveA, uint reserveB) external pure returns (uint amountB);\r\nfunction getAmountOut(uint amountIn, uint reserveIn, uint reserveOut) external pure returns (uint amountOut);\r\nfunction getAmountIn(uint amountOut, uint reserveIn, uint reserveOut) external pure returns (uint amountIn);\r\nfunction getAmountsOut(uint amountIn, address[] calldata path) external view returns (uint[] memory amounts);\r\nfunction getAmountsIn(uint amountOut, address[] calldata path) external view returns (uint[] memory amounts);\r\n}\r\ninterface IUniswapV2Router02 is IUniswapV2Router01 {\r\nfunction removeLiquidityETHSupportingFeeOnTransferTokens(\r\n    address token,\r\n    uint liquidity,\r\n    uint amountTokenMin,\r\n    uint amountETHMin,\r\n    address to,\r\n    uint deadline\r\n) external returns (uint amountETH);\r\nfunction removeLiquidityETHWithPermitSupportingFeeOnTransferTokens(\r\n    address token,\r\n    uint liquidity,\r\n    uint amountTokenMin,\r\n    uint amountETHMin,\r\n    address to,\r\n    uint deadline,\r\n    bool approveMax, uint8 v, bytes32 r, bytes32 s\r\n) external returns (uint amountETH);\r\nfunction swapExactTokensForTokensSupportingFeeOnTransferTokens(\r\n    uint amountIn,\r\n    uint amountOutMin,\r\n    address[] calldata path,\r\n    address to,\r\n    uint deadline\r\n) external;\r\nfunction swapExactETHForTokensSupportingFeeOnTransferTokens(\r\n    uint amountOutMin,\r\n    address[] calldata path,\r\n    address to,\r\n    uint deadline\r\n) external payable;\r\nfunction swapExactTokensForETHSupportingFeeOnTransferTokens(\r\n    uint amountIn,\r\n    uint amountOutMin,\r\n    address[] calldata path,\r\n    address to,\r\n    uint deadline\r\n) external;\r\n}", "ABI": "[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"pair\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"bool\",\"name\":\"value\",\"type\":\"bool\"}],\"name\":\"SetAutomatedMarketMakerPair\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tokensSwapped\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"ethReceived\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tokensIntoLiquidity\",\"type\":\"uint256\"}],\"name\":\"SwapAndLiquify\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"tokensSwappedDuringTokenomics\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address payable\",\"name\":\"detectedBot\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"isBot\",\"type\":\"bool\"}],\"name\":\"addBotWallet\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"toExclude\",\"type\":\"address\"}],\"name\":\"addToExcluded\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"automatedMarketMakerPairs\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"newAmount\",\"type\":\"uint256\"}],\"name\":\"buyFee\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"currentLiqTokens\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"currentMaxTx\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"currentMaxWallet\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"currentSwap\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"currentThresholdInt\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"currentTokensToSwap\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"currentTrade\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"currentbuyliqFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"currentbuymktfee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"currentmktTokens\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"currentsellLiqFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"currentsellmktfee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"deadAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getOwner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"inSwapAndLiquify\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"toCheck\",\"type\":\"address\"}],\"name\":\"isExcluded\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"marketingAddress\",\"outputs\":[{\"internalType\":\"address payable\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"toRemove\",\"type\":\"address\"}],\"name\":\"removeFromExcluded\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"requiredTokensToSwap\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"newAmount\",\"type\":\"uint256\"}],\"name\":\"sellFee\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newAddress\",\"type\":\"address\"}],\"name\":\"setMktAddress\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"swapAndLiquifyEnabled\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"status\",\"type\":\"bool\"}],\"name\":\"tradeStatus\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"uniswapV2Pair\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"newVal\",\"type\":\"uint256\"}],\"name\":\"updateMaxTxTreshold\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"newVal\",\"type\":\"uint256\"}],\"name\":\"updateMaxWalletTreshold\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"newVal\",\"type\":\"uint256\"}],\"name\":\"updateSwapTreshold\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"newThreshold\",\"type\":\"uint256\"}],\"name\":\"updateThreshold\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]", "ContractName": "MILLIONAIRE", "CompilerVersion": "v0.8.0+commit.c7dfd78e", "CompilerType": "solc", "OptimizationUsed": "0", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "ContractFileName": "", "LicenseType": "MIT", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://8d20e73a7927c7da12cc60a7f47e1d2763a1fe5bb0b1050290ccf556ab571dc1", "SimilarMatch": ""}